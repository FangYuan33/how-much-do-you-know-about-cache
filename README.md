## 网海流量凶，缓存知多少

### 热 key 问题如何解决

某个或某些特定的缓存键被频繁访问，导致这些键的访问量远超其他键。这种情况可能会导致缓存服务器的负载不均衡，某个节点负载很高，其他节点十分空闲，占用大量 CPU 使其性能变差进而影响其他请求，甚至造成访问压力过大超出缓存的承载能在造成缓存击穿，导致大量请求直接指向后端数据库，造成数据库宕机，影响业务。

解决该问题的核心是 **“缓存分片”**，如果使用的是分布式缓存，可以为分布式缓存添加多个节点，这样便**将热 key 分散到多个缓存节点上**，通过轮询或其他负载均衡算法将流量打散，从而避免单个缓存节点压力过大。另一种解决方案是在应用服务器上使用本地缓存，本质上也是为缓存做了分片，将访问的流量打散，分布到各个应用服务器上，降低单台服务器的压力。

### 大 key 问题如何解决

大 key 问题通常是指在缓存系统（如 Redis）中，某个 key 对应的数据量过大，导致缓存操作（如读、写、删除）性能下降，甚至可能影响整个缓存系统的稳定性。解决大 key 问题可以考虑以下策略：

1. **数据拆分**：将大 key 的数据拆分成多个小 key。可以根据业务逻辑对数据进行分片，例如按时间、用户 ID、类别等进行拆分。这样可以减少单个 key 的数据量，提高缓存操作的性能。

2. **分批操作**：在读取或写入大 key 时，采用分批次的方式进行操作，避免一次性处理过多数据。

3. **压缩数据**：对存储的数据进行压缩，减少数据占用的空间。使用如 GZIP 等压缩算法来压缩存储的数据，在读取时进行解压。

4. **使用合适的数据结构**：根据数据特性选择合适的数据结构存储，避免使用复杂度高的数据结构。

### 缓存穿透

缓存穿透是指查询一个不存在的数据时，由于缓存中也没有该数据，导致每次请求都直接访问底层数据源（如数据库），从而失去了缓存的意义，并可能对数据源造成过大压力。以下是几种常见的解决缓存穿透问题的方法：

1. **缓存空结果**：当查询结果为空（例如数据库中没有对应记录）时，将这个“空结果”也缓存起来。下次再遇到相同的请求时，可以直接返回缓存的空结果，而不需要访问数据库（需要注意设置一个较短的过期时间，以防止临时数据占用缓存空间过久）

2. **使用布隆过滤器**：在缓存层之前使用布隆过滤器来判断请求的 key 是否可能存在于数据库中。布隆过滤器是一种概率数据结构，可以高效地判断一个元素是否在集合中。 如果布隆过滤器判断一个 key 不存在，则直接返回空结果，避免访问数据库。但是这种方案需要考虑到布隆过滤器的误判率，以及如何处理误判的情况。

3. **限流与熔断**：对请求进行限流，限制单位时间内对某些 key 的访问频率。配合熔断机制，在检测到某些 key 的请求频率过高时，直接返回默认响应，避免进一步的缓存穿透。

4. **异步更新缓存**：对于某些高并发请求，可以异步更新缓存。即当缓存未命中时，直接返回默认值，同时异步地去更新缓存。这种方法适用于对实时性要求不高的场景。

5. **参数合法性校验**：在进入缓存查询之前，对请求参数进行合法性校验，过滤掉明显不合法的请求。这可以防止一些恶意请求或无效请求直接击穿缓存。

6. **监控与报警**：实时监控缓存命中率和数据库请求量，当检测到异常情况时及时报警，以便快速响应和处理问题。通过分析日志和监控数据，可以找到潜在的缓存穿透来源。

### 缓存击穿

缓存击穿是指在高并发环境下，某个热点数据在缓存过期的瞬间，大量请求同时到达数据库，导致数据库压力骤增的问题。为了解决缓存击穿，可以采用以下策略：

1. **热点数据永不过期**：对于一些特别重要的热点数据，可以设置为永不过期，这样可以确保热点数据始终存在于缓存中，避免缓存失效。

2. **缓存预热**：在系统启动或热点数据更新时，提前将热点数据加载到缓存中。这样可以避免在缓存未命中时，大量请求直接访问数据库。

3. **限流策略**：通过限流策略，控制进入数据库的请求数量，防止数据库过载。

4. **使用互斥锁（Mutex）**：在缓存失效时，通过互斥锁（例如使用分布式锁）来控制只有一个请求能够查询数据库并更新缓存。

### 缓存雪崩

缓存雪崩是指缓存中的大量数据在同一时间过期（或者缓存服务宕机），导致大量请求直接落到数据库上，可能引发数据库压力过大甚至崩溃的问题。为了解决缓存雪崩问题，可以采取以下措施：

1. **缓存过期时间分散**：在设置缓存过期时间时，加入一定的随机值，使不同缓存的过期时间分散开来，避免同一时间大量缓存同时失效。

2. **缓存双活**：使用主缓存和备份缓存，当主缓存过期时，先从备份缓存中获取数据，同时异步更新主缓存。这样即使主缓存过期，也可以通过备份缓存提供服务，减轻对数据库的直接请求压力。

3. **请求锁**：在缓存失效时，使用分布式锁（如 Redis 分布式锁）来保证只有一个请求去加载数据并更新缓存，其他请求等待锁释放后再从缓存中获取数据。这样可以防止缓存失效后大量请求同时访问数据库。

4. **限流和降级**：在缓存失效导致数据库压力过大时，可以通过限流来控制请求的数量，防止数据库被压垮。使用服务降级策略，在数据库无法承受高负载时，返回默认数据或提示信息，以保证系统的可用性。

5. **多级缓存**：使用多级缓存策略，例如在本地缓存和分布式缓存之间进行分层，先查询本地缓存，再查询分布式缓存，最后才访问数据库。这种方式可以减少对数据库的直接访问压力。

### hash tag 的妙用

针对需要批量获取或操作缓存（lua 脚本更新多个缓存）的场景，可以使用 hash tag 使这些键在一个分片上，提高操作效率。

---

### 巨人的肩膀

- [CoolShell - 缓存更新的套路](https://coolshell.cn/articles/17416.html)
- [Java全栈知识体系 - JUC集合](https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#concurrenthashmap-jdk-1-8)
- [Github - Caffeine](https://github.com/ben-manes/caffeine)
- [High Scalability - Design of a Modern Cache](https://highscalability.com/design-of-a-modern-cache/)
- [现代化的缓存设计方案](http://ifeve.com/design-of-a-modern-cache/)
- [High Scalability - Cache Eviction and Expiration Policy](https://highscalability.com/design-of-a-modern-cachepart-deux/)
